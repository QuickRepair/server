#ifndef ACCOUNT_H
#define ACCOUNT_H

#include <string>
#include <unordered_map>
#include <list>
#include <memory>
#include "types.h"
/// must include due to unique_ptr error !!!
#include "MerchantService.h"
/// must include due unique_ptr error !!!

class Order;

enum class AccountType {
	Merchant, Customer, Unknown
};

/// @brief the super class of all account(CustomerAccount and MerchantAccount)
class Account
{
public:
	/// @param id: the unique identity of account, generated by system
	/// @param account: the phone number of an account
	/// @param password: password of the account
    explicit Account(AccountId id);
    virtual ~Account() = default;

    /// @brief Test if the given order belong to the account
    /// @return true if the order belong to the account, false if not
//	virtual bool isMyOrder(std::weak_ptr<Order> order) const = 0;

	/// @brief setters and getters
	AccountId id() const;
	const std::string password() const;
	void setPassword(const std::string &password);
	const std::string account() const;
	void setAccount(const std::string &userName);
	const std::string name() const;
	void setName(const std::string &name);

protected:
	/// @brief load contanct information for the account, can only be called by factories
//	virtual void loadContactInformation(std::list<std::shared_ptr<ContactInformation>> info) = 0;

	/// @brief load orders belong to the account, can only be called by factories
//	virtual void loadOrder(std::shared_ptr<Order> order) = 0;

	AccountId m_id;
//	std::string m_account;
//    std::string m_password;
};

/// @brief a subclass of Account, represent a customer who is using the system
class CustomerAccount : public Account
{
	friend class CustomerFactory;
	friend class OrderFactory;
	friend class OrderManager;

public:
	explicit CustomerAccount(AccountId id);

	/// @brief Get order list of the account
	/// @return return the order list belong to the account
	virtual std::list<std::weak_ptr<Order>> getOrderList() const;

	/// @brief CustomerAccount specific operation, publish a new order to system
	/// @param order: a weak_ptr to the new order
	void iAmPublishAnOrder(std::weak_ptr<Order> order);

	/// @brief CustomerAccount specific operation, cancel a order belong to the customer
	/// @param order: a weak_ptr to the order
	// TODO: add some cancelable limit here
//    void cancelOrder(std::weak_ptr<Order> order);

	/// @brief CustomerAccount specific operation, evaluate the order after finish repair
	/// @param order: a weak_ptr to the order
	/// @param evaluate: the evaluate add to order
//    void evaluateTheOrder(std::weak_ptr<Order> order, OrderEvaluate evaluate);

	/// @brief CustomerAccount specific operation, pay for the order after finish repair
	/// @param order: a weak_ptr to the order
//    void payTheOrder(std::weak_ptr<Order> order);

	///@override
//    bool isMyOrder(std::weak_ptr<Order> order) const override;
//	std::list<std::weak_ptr<Order>> myOrdersList() const override;

protected:
	///@override
//	void loadContactInformation(std::list<std::shared_ptr<ContactInformation>> info) override;
//	void loadOrder(std::shared_ptr<Order> order) override;

//    std::list<std::shared_ptr<ContactInformation>> m_contactInfo;
	std::unordered_map<OrderId, std::shared_ptr<Order>> m_orders;
};

/// @brief a subclass of Account, represent a merchant who is using the system
class MerchantAccount : public CustomerAccount
{
	friend class MerchantFactory;
public:
	explicit MerchantAccount(AccountId id);

	/// @brief MerchantAccount specific operation, register an not accepted order belong to the merchant
	/// @param order: a weak_ptr to the order
	void orderWaitToBeAccept(std::weak_ptr<Order> order);

	/// @brief MerchantAccount specific operation, accept an order which was registered by @orderWaitToBeAccept()
	/// @param order: a weak_ptr to the order
//    void acceptOrder(std::weak_ptr<Order> order);

	/// @brief MerchantAccount specific operation, start repair an order belong to the merchant
	/// @param order: a weak_ptr to the order
//    void startRepair(std::weak_ptr<Order> order);

	/// @brief MerchantAccount specific operation, end repair an order belong to the merchant
	/// @param order: a weak_ptr to the order
	/// @param transaction: the price of the order
//    void endRepair(std::weak_ptr<Order> order, double transaction);

	/// @brief MerchantAccount specific operation, reject an order which was registered by @orderWaitToBeAccept()
//	void rejectOrder(std::weak_ptr<Order> order);

	/// @brief Test if the order belong to the merchant submitted/processed/unreceived orders
	/// @param order: a weak_ptr to the order
	/// @return true if the order is in the list, false on the contrary
//	bool isMySubmittedOrder(std::weak_ptr<Order> order) const;
//	bool isMyProcessedOrder(std::weak_ptr<Order> order) const;
//	bool isMyUnreceivedOrder(std::weak_ptr<Order> order) const;

	/// @brief Get all unreceived orders
	/// @return a list of weak_ptr to unreceived orders
//	std::list<std::weak_ptr<Order>> myUnreceivedOrderList() const;

	/// @override
//    bool isMyOrder(std::weak_ptr<Order> order) const override;
//	std::list<std::weak_ptr<Order>> myOrdersList() const override;

	/// @brief Get merchant supported service type
	/// @return a ptr to service type
	MerchantService *getService();

	/// @brief Update the merchant service type
	/// @param appliancType: a list of supported appliance type
	/// @param maxDistance: the merchant max service distance
//	void updateSupportedService(std::list<std::string> appliancType, double maxDistance);

protected:
	/// @override
//	void loadContactInformation(std::list<std::shared_ptr<ContactInformation>> info) override;
//	void loadOrder(std::shared_ptr<Order> order) override;

	/// @brief Load merchant service type
	/// @param service: a shared_ptr to service type
//	void loadServiceType(std::unique_ptr<MerchantService> &&service);

private:
	std::unique_ptr<MerchantService> m_serviceType;
//    std::unordered_map<unsigned long, std::shared_ptr<Order>> m_processedOrders;
//    std::unordered_map<unsigned long, std::shared_ptr<Order>> m_unreceivedOrders;
};

#endif // ACCOUNT_H
